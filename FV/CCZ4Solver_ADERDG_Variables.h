// This file is generated by the ExaHyPE toolkit.
// Please do not modify - it will be overwritten by the next
// ExaHyPE toolkit call.
// 
// ========================
//   www.exahype.eu
// ========================
// ==============================================
// Please do not change the implementations below
// =============================---==============
#ifndef __CCZ4Solver_ADERDG_Variables_CLASS_HEADER__
#define __CCZ4Solver_ADERDG_Variables_CLASS_HEADER__

#include "AbstractCCZ4Solver_ADERDG.h"

#include <algorithm>

#include "tarch/la/Matrix.h"

/**
 * Generic information about the variable string as it was declared in the
 * specification file
 **/
struct CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
  static constexpr int numDistinctVariables = 20;
  static constexpr int SizeVariables  = 63; 
  static constexpr int SizeParameters = 0;
  static constexpr int Size           = 63+0;
  static constexpr int Dimensions     = DIMENSIONS;
};

/**
 * Positions of fields in the vector of unkonwns.
 *
 * With these constants, you can write Q[g11], Q[K22] and Q[B33] instead of
 * Q[0], Q[9] and Q[34]. Your code is meaningful in terms of physics while
 * you still access on a C-array level.
 *
 * You might want to use a typedef to shorten the notation or create 
 * an instance of this class.
 **/
class CCZ4::AbstractCCZ4Solver_ADERDG::VariableShortcuts : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
  const int _Q[numDistinctVariables + 1] = { 0,6,12,13,16,17,20,23,26,29,32,35,41,47,53,54,55,58,59,60 };

  const int G = 0;
  const int K = 6;
  const int theta = 12;
  const int Z = 13;
  const int lapse = 16;
  const int shift = 17;
  const int b = 20;
  const int dLapse = 23;
  const int dxShift = 26;
  const int dyShift = 29;
  const int dzShift = 32;
  const int dxG = 35;
  const int dyG = 41;
  const int dzG = 47;
  const int traceK = 53;
  const int phi = 54;
  const int P = 55;
  const int K0 = 58;
  const int domain = 59;
  const int pos = 60;

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableShortcuts

/**
 * Lengths (multplicities) of each field inside the unknown vector Q.
 * For instance, 0 means "scalar field" while any value >0 may mean a vector field or
 * even a "linearized" tensor field
 **/
class CCZ4::AbstractCCZ4Solver_ADERDG::VariableMultiplicities : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
public:
  /// positions of fields inside the unknown vector (solution vector) Q
 
  const int _Q[numDistinctVariables] = { 6,6,1,3,1,3,3,3,3,3,3,6,6,6,1,1,3,1,1,3 };

  const int G = 6;
  const int K = 6;
  const int theta = 1;
  const int Z = 3;
  const int lapse = 1;
  const int shift = 3;
  const int b = 3;
  const int dLapse = 3;
  const int dxShift = 3;
  const int dyShift = 3;
  const int dzShift = 3;
  const int dxG = 6;
  const int dyG = 6;
  const int dzG = 6;
  const int traceK = 1;
  const int phi = 1;
  const int P = 3;
  const int K0 = 1;
  const int domain = 1;
  const int pos = 3;

  const int* asArray() const { return _Q; }
  int operator [] (int index) const { return _Q[index]; }
  int operator () (int index) const { return _Q[index]; }
}; // end of VariableMultiplicities

/**
 * Variable names as strings as given in the toolkit.
 * 
 * These names might want to be used for plotting, output, etc.
 *
 **/
class CCZ4::AbstractCCZ4Solver_ADERDG::VariableNames : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
public:
  char const *_Q[numDistinctVariables + 1] = { "G","K","theta","Z","lapse","shift","b","dLapse","dxShift","dyShift","dzShift","dxG","dyG","dzG","traceK","phi","P","K0","domain","pos" };

  const char* G = "G";
  const char* K = "K";
  const char* theta = "theta";
  const char* Z = "Z";
  const char* lapse = "lapse";
  const char* shift = "shift";
  const char* b = "b";
  const char* dLapse = "dLapse";
  const char* dxShift = "dxShift";
  const char* dyShift = "dyShift";
  const char* dzShift = "dzShift";
  const char* dxG = "dxG";
  const char* dyG = "dyG";
  const char* dzG = "dzG";
  const char* traceK = "traceK";
  const char* phi = "phi";
  const char* P = "P";
  const char* K0 = "K0";
  const char* domain = "domain";
  const char* pos = "pos";

  const char* const* asArray() const { return _Q; } // type: whatever
  const char* operator [] (int index) const { return _Q[index]; }
  const char* operator () (int index) const { return _Q[index]; }
}; // end of VariableNames

/**
 * Positions of fields in the vector of unknowns,
 * available as namespace constants.
 * 
 * You can use this namespace similar to the class "VariableShortcuts"
 * but you don't need an object, ie. your notation can get slimmer.
 * 
 * Usage is like:
 * 
 *    void somewhere() {
 *       using namespace CCZ4::CCZ4Solver_ADERDG_Variables::shortcuts;
 *       Q[foo] = 17;
 *    }
 *
 * instead of
 * 
 *    void somewhere() {
 *       CCZ4::AbstractCCZ4Solver_ADERDG::VariableNames q;
 *       Q[q.foo] = 17;
 *    }
 *
 **/
namespace CCZ4 {
  namespace CCZ4Solver_ADERDG_Variables {
    namespace shortcuts {
      constexpr int G = 0;
      constexpr int K = 6;
      constexpr int theta = 12;
      constexpr int Z = 13;
      constexpr int lapse = 16;
      constexpr int shift = 17;
      constexpr int b = 20;
      constexpr int dLapse = 23;
      constexpr int dxShift = 26;
      constexpr int dyShift = 29;
      constexpr int dzShift = 32;
      constexpr int dxG = 35;
      constexpr int dyG = 41;
      constexpr int dzG = 47;
      constexpr int traceK = 53;
      constexpr int phi = 54;
      constexpr int P = 55;
      constexpr int K0 = 58;
      constexpr int domain = 59;
      constexpr int pos = 60;
    } // namespace shortcuts
    namespace names {
      constexpr char G[] = "G"; 
      constexpr char K[] = "K"; 
      constexpr char theta[] = "theta"; 
      constexpr char Z[] = "Z"; 
      constexpr char lapse[] = "lapse"; 
      constexpr char shift[] = "shift"; 
      constexpr char b[] = "b"; 
      constexpr char dLapse[] = "dLapse"; 
      constexpr char dxShift[] = "dxShift"; 
      constexpr char dyShift[] = "dyShift"; 
      constexpr char dzShift[] = "dzShift"; 
      constexpr char dxG[] = "dxG"; 
      constexpr char dyG[] = "dyG"; 
      constexpr char dzG[] = "dzG"; 
      constexpr char traceK[] = "traceK"; 
      constexpr char phi[] = "phi"; 
      constexpr char P[] = "P"; 
      constexpr char K0[] = "K0"; 
      constexpr char domain[] = "domain"; 
      constexpr char pos[] = "pos"; 
    } // namespace names
  } // end of namespace CCZ4::CCZ4Solver_ADERDG_Variables 
} // end of namespace CCZ4

/*
 * Another class idea:
 * 
 * class ....::VariablePointers {
 *   private:   double* Q;
 *   public:
 *      double &varfoo;
 *      double &varbar;
 *      VariablePointers(double* const Q) : varfoo(Q[0]), bar(Q[1]), ... {}
 * }
 * 
 * Advantages: Use as positions in Q.
 *
 */


class CCZ4::AbstractCCZ4Solver_ADERDG::ReadOnlyVariables : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
  private:
    const double* const _Q;
  public:
    ReadOnlyVariables(const double* const Q) : _Q(Q) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    const double* data() const {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // getters for G 
    double G(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[0+index];
    }
    tarch::la::Vector<6,double> G() const {
      tarch::la::Vector<6,double> values;
      values=_Q[0],_Q[1],_Q[2],_Q[3],_Q[4],_Q[5];
      return values;
    }
        
    // getters for K 
    double K(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[6+index];
    }
    tarch::la::Vector<6,double> K() const {
      tarch::la::Vector<6,double> values;
      values=_Q[6],_Q[7],_Q[8],_Q[9],_Q[10],_Q[11];
      return values;
    }
        
    // getter and setter for theta
    double theta() const {return _Q[12];}
        
    // getters for Z 
    double Z(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[13+index];
    }
    tarch::la::Vector<3,double> Z() const {
      tarch::la::Vector<3,double> values;
      values=_Q[13],_Q[14],_Q[15];
      return values;
    }
        
    // getter and setter for lapse
    double lapse() const {return _Q[16];}
        
    // getters for shift 
    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[17+index];
    }
    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[17],_Q[18],_Q[19];
      return values;
    }
        
    // getters for b 
    double b(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[20+index];
    }
    tarch::la::Vector<3,double> b() const {
      tarch::la::Vector<3,double> values;
      values=_Q[20],_Q[21],_Q[22];
      return values;
    }
        
    // getters for dLapse 
    double dLapse(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[23+index];
    }
    tarch::la::Vector<3,double> dLapse() const {
      tarch::la::Vector<3,double> values;
      values=_Q[23],_Q[24],_Q[25];
      return values;
    }
        
    // getters for dxShift 
    double dxShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[26+index];
    }
    tarch::la::Vector<3,double> dxShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[26],_Q[27],_Q[28];
      return values;
    }
        
    // getters for dyShift 
    double dyShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[29+index];
    }
    tarch::la::Vector<3,double> dyShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[29],_Q[30],_Q[31];
      return values;
    }
        
    // getters for dzShift 
    double dzShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[32+index];
    }
    tarch::la::Vector<3,double> dzShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[32],_Q[33],_Q[34];
      return values;
    }
        
    // getters for dxG 
    double dxG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[35+index];
    }
    tarch::la::Vector<6,double> dxG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[35],_Q[36],_Q[37],_Q[38],_Q[39],_Q[40];
      return values;
    }
        
    // getters for dyG 
    double dyG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[41+index];
    }
    tarch::la::Vector<6,double> dyG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[41],_Q[42],_Q[43],_Q[44],_Q[45],_Q[46];
      return values;
    }
        
    // getters for dzG 
    double dzG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[47+index];
    }
    tarch::la::Vector<6,double> dzG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[47],_Q[48],_Q[49],_Q[50],_Q[51],_Q[52];
      return values;
    }
        
    // getter and setter for traceK
    double traceK() const {return _Q[53];}
        
    // getter and setter for phi
    double phi() const {return _Q[54];}
        
    // getters for P 
    double P(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[55+index];
    }
    tarch::la::Vector<3,double> P() const {
      tarch::la::Vector<3,double> values;
      values=_Q[55],_Q[56],_Q[57];
      return values;
    }
        
    // getter and setter for K0
    double K0() const {return _Q[58];}
        
    // getter and setter for domain
    double domain() const {return _Q[59];}
        
    // getters for pos 
    double pos(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[60+index];
    }
    tarch::la::Vector<3,double> pos() const {
      tarch::la::Vector<3,double> values;
      values=_Q[60],_Q[61],_Q[62];
      return values;
    }
        
}; // end of ReadOnlyVariables


class CCZ4::AbstractCCZ4Solver_ADERDG::Variables : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics{
  private:
    double* const _Q;
  public:
    static constexpr int SizeVariables  = 63;
    static constexpr int SizeParameters = 0;
    static constexpr int Size           = 63+0;
  
    Variables(double* const Q) : _Q(Q) {}
    
    void operator = (Variables& variables) {
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    void operator = (ReadOnlyVariables& variables) {
      assertion(variables.variables()==SizeVariables);
      assertion(variables.parameters()==SizeParameters);
      assertion(variables.size()==Size);
      std::copy(variables.data(),variables.data()+Size,_Q);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _Q[index];
    }
    
    double* data() {
      return _Q;
    }
    
    int size() const {
      return Size;
    }
    
    int variables() const {
      return SizeVariables;
    }
    
    int parameters() const {
      return SizeParameters;
    }

    // getters for G 
    double G(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[0+index];
    }
    tarch::la::Vector<6,double> G() const {
      tarch::la::Vector<6,double> values;
      values=_Q[0],_Q[1],_Q[2],_Q[3],_Q[4],_Q[5];
      return values;
    }
    // setters for G
    double& G(int index) {return _Q[0+index];}
    void G(const tarch::la::Vector<6,double>& values) const {
      _Q[0] = values[0];
      _Q[1] = values[1];
      _Q[2] = values[2];
      _Q[3] = values[3];
      _Q[4] = values[4];
      _Q[5] = values[5];
    }
    void G(double G0,double G1,double G2,double G3,double G4,double G5) {
      _Q[0] = G0;
      _Q[1] = G1;
      _Q[2] = G2;
      _Q[3] = G3;
      _Q[4] = G4;
      _Q[5] = G5;
    }
    
    // getters for K 
    double K(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[6+index];
    }
    tarch::la::Vector<6,double> K() const {
      tarch::la::Vector<6,double> values;
      values=_Q[6],_Q[7],_Q[8],_Q[9],_Q[10],_Q[11];
      return values;
    }
    // setters for K
    double& K(int index) {return _Q[6+index];}
    void K(const tarch::la::Vector<6,double>& values) const {
      _Q[6] = values[0];
      _Q[7] = values[1];
      _Q[8] = values[2];
      _Q[9] = values[3];
      _Q[10] = values[4];
      _Q[11] = values[5];
    }
    void K(double K0,double K1,double K2,double K3,double K4,double K5) {
      _Q[6] = K0;
      _Q[7] = K1;
      _Q[8] = K2;
      _Q[9] = K3;
      _Q[10] = K4;
      _Q[11] = K5;
    }
    
    // getter and setter for theta
    double theta() const {return _Q[12];}
    double& theta() {return _Q[12];}
    
    // getters for Z 
    double Z(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[13+index];
    }
    tarch::la::Vector<3,double> Z() const {
      tarch::la::Vector<3,double> values;
      values=_Q[13],_Q[14],_Q[15];
      return values;
    }
    // setters for Z
    double& Z(int index) {return _Q[13+index];}
    void Z(const tarch::la::Vector<3,double>& values) const {
      _Q[13] = values[0];
      _Q[14] = values[1];
      _Q[15] = values[2];
    }
    void Z(double Z0,double Z1,double Z2) {
      _Q[13] = Z0;
      _Q[14] = Z1;
      _Q[15] = Z2;
    }
    
    // getter and setter for lapse
    double lapse() const {return _Q[16];}
    double& lapse() {return _Q[16];}
    
    // getters for shift 
    double shift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[17+index];
    }
    tarch::la::Vector<3,double> shift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[17],_Q[18],_Q[19];
      return values;
    }
    // setters for shift
    double& shift(int index) {return _Q[17+index];}
    void shift(const tarch::la::Vector<3,double>& values) const {
      _Q[17] = values[0];
      _Q[18] = values[1];
      _Q[19] = values[2];
    }
    void shift(double shift0,double shift1,double shift2) {
      _Q[17] = shift0;
      _Q[18] = shift1;
      _Q[19] = shift2;
    }
    
    // getters for b 
    double b(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[20+index];
    }
    tarch::la::Vector<3,double> b() const {
      tarch::la::Vector<3,double> values;
      values=_Q[20],_Q[21],_Q[22];
      return values;
    }
    // setters for b
    double& b(int index) {return _Q[20+index];}
    void b(const tarch::la::Vector<3,double>& values) const {
      _Q[20] = values[0];
      _Q[21] = values[1];
      _Q[22] = values[2];
    }
    void b(double b0,double b1,double b2) {
      _Q[20] = b0;
      _Q[21] = b1;
      _Q[22] = b2;
    }
    
    // getters for dLapse 
    double dLapse(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[23+index];
    }
    tarch::la::Vector<3,double> dLapse() const {
      tarch::la::Vector<3,double> values;
      values=_Q[23],_Q[24],_Q[25];
      return values;
    }
    // setters for dLapse
    double& dLapse(int index) {return _Q[23+index];}
    void dLapse(const tarch::la::Vector<3,double>& values) const {
      _Q[23] = values[0];
      _Q[24] = values[1];
      _Q[25] = values[2];
    }
    void dLapse(double dLapse0,double dLapse1,double dLapse2) {
      _Q[23] = dLapse0;
      _Q[24] = dLapse1;
      _Q[25] = dLapse2;
    }
    
    // getters for dxShift 
    double dxShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[26+index];
    }
    tarch::la::Vector<3,double> dxShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[26],_Q[27],_Q[28];
      return values;
    }
    // setters for dxShift
    double& dxShift(int index) {return _Q[26+index];}
    void dxShift(const tarch::la::Vector<3,double>& values) const {
      _Q[26] = values[0];
      _Q[27] = values[1];
      _Q[28] = values[2];
    }
    void dxShift(double dxShift0,double dxShift1,double dxShift2) {
      _Q[26] = dxShift0;
      _Q[27] = dxShift1;
      _Q[28] = dxShift2;
    }
    
    // getters for dyShift 
    double dyShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[29+index];
    }
    tarch::la::Vector<3,double> dyShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[29],_Q[30],_Q[31];
      return values;
    }
    // setters for dyShift
    double& dyShift(int index) {return _Q[29+index];}
    void dyShift(const tarch::la::Vector<3,double>& values) const {
      _Q[29] = values[0];
      _Q[30] = values[1];
      _Q[31] = values[2];
    }
    void dyShift(double dyShift0,double dyShift1,double dyShift2) {
      _Q[29] = dyShift0;
      _Q[30] = dyShift1;
      _Q[31] = dyShift2;
    }
    
    // getters for dzShift 
    double dzShift(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[32+index];
    }
    tarch::la::Vector<3,double> dzShift() const {
      tarch::la::Vector<3,double> values;
      values=_Q[32],_Q[33],_Q[34];
      return values;
    }
    // setters for dzShift
    double& dzShift(int index) {return _Q[32+index];}
    void dzShift(const tarch::la::Vector<3,double>& values) const {
      _Q[32] = values[0];
      _Q[33] = values[1];
      _Q[34] = values[2];
    }
    void dzShift(double dzShift0,double dzShift1,double dzShift2) {
      _Q[32] = dzShift0;
      _Q[33] = dzShift1;
      _Q[34] = dzShift2;
    }
    
    // getters for dxG 
    double dxG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[35+index];
    }
    tarch::la::Vector<6,double> dxG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[35],_Q[36],_Q[37],_Q[38],_Q[39],_Q[40];
      return values;
    }
    // setters for dxG
    double& dxG(int index) {return _Q[35+index];}
    void dxG(const tarch::la::Vector<6,double>& values) const {
      _Q[35] = values[0];
      _Q[36] = values[1];
      _Q[37] = values[2];
      _Q[38] = values[3];
      _Q[39] = values[4];
      _Q[40] = values[5];
    }
    void dxG(double dxG0,double dxG1,double dxG2,double dxG3,double dxG4,double dxG5) {
      _Q[35] = dxG0;
      _Q[36] = dxG1;
      _Q[37] = dxG2;
      _Q[38] = dxG3;
      _Q[39] = dxG4;
      _Q[40] = dxG5;
    }
    
    // getters for dyG 
    double dyG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[41+index];
    }
    tarch::la::Vector<6,double> dyG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[41],_Q[42],_Q[43],_Q[44],_Q[45],_Q[46];
      return values;
    }
    // setters for dyG
    double& dyG(int index) {return _Q[41+index];}
    void dyG(const tarch::la::Vector<6,double>& values) const {
      _Q[41] = values[0];
      _Q[42] = values[1];
      _Q[43] = values[2];
      _Q[44] = values[3];
      _Q[45] = values[4];
      _Q[46] = values[5];
    }
    void dyG(double dyG0,double dyG1,double dyG2,double dyG3,double dyG4,double dyG5) {
      _Q[41] = dyG0;
      _Q[42] = dyG1;
      _Q[43] = dyG2;
      _Q[44] = dyG3;
      _Q[45] = dyG4;
      _Q[46] = dyG5;
    }
    
    // getters for dzG 
    double dzG(int index) const {
      assertion(index >= 0 && index<6);
      return _Q[47+index];
    }
    tarch::la::Vector<6,double> dzG() const {
      tarch::la::Vector<6,double> values;
      values=_Q[47],_Q[48],_Q[49],_Q[50],_Q[51],_Q[52];
      return values;
    }
    // setters for dzG
    double& dzG(int index) {return _Q[47+index];}
    void dzG(const tarch::la::Vector<6,double>& values) const {
      _Q[47] = values[0];
      _Q[48] = values[1];
      _Q[49] = values[2];
      _Q[50] = values[3];
      _Q[51] = values[4];
      _Q[52] = values[5];
    }
    void dzG(double dzG0,double dzG1,double dzG2,double dzG3,double dzG4,double dzG5) {
      _Q[47] = dzG0;
      _Q[48] = dzG1;
      _Q[49] = dzG2;
      _Q[50] = dzG3;
      _Q[51] = dzG4;
      _Q[52] = dzG5;
    }
    
    // getter and setter for traceK
    double traceK() const {return _Q[53];}
    double& traceK() {return _Q[53];}
    
    // getter and setter for phi
    double phi() const {return _Q[54];}
    double& phi() {return _Q[54];}
    
    // getters for P 
    double P(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[55+index];
    }
    tarch::la::Vector<3,double> P() const {
      tarch::la::Vector<3,double> values;
      values=_Q[55],_Q[56],_Q[57];
      return values;
    }
    // setters for P
    double& P(int index) {return _Q[55+index];}
    void P(const tarch::la::Vector<3,double>& values) const {
      _Q[55] = values[0];
      _Q[56] = values[1];
      _Q[57] = values[2];
    }
    void P(double P0,double P1,double P2) {
      _Q[55] = P0;
      _Q[56] = P1;
      _Q[57] = P2;
    }
    
    // getter and setter for K0
    double K0() const {return _Q[58];}
    double& K0() {return _Q[58];}
    
    // getter and setter for domain
    double domain() const {return _Q[59];}
    double& domain() {return _Q[59];}
    
    // getters for pos 
    double pos(int index) const {
      assertion(index >= 0 && index<3);
      return _Q[60+index];
    }
    tarch::la::Vector<3,double> pos() const {
      tarch::la::Vector<3,double> values;
      values=_Q[60],_Q[61],_Q[62];
      return values;
    }
    // setters for pos
    double& pos(int index) {return _Q[60+index];}
    void pos(const tarch::la::Vector<3,double>& values) const {
      _Q[60] = values[0];
      _Q[61] = values[1];
      _Q[62] = values[2];
    }
    void pos(double pos0,double pos1,double pos2) {
      _Q[60] = pos0;
      _Q[61] = pos1;
      _Q[62] = pos2;
    }
    
}; // end of Variables


class CCZ4::AbstractCCZ4Solver_ADERDG::Fluxes : public CCZ4::AbstractCCZ4Solver_ADERDG::VariableMetrics {
  private:
    double** const _F;
  public:
    Fluxes(double** const F) : _F(F) {}
    
    /** The rows of the flux tensor. */
    int variables() const {
      return SizeVariables;
    }
    
    /** The columns of the flux tensor. */
    int dimensions() const {
      return Dimensions;
    }


    // getters for G
    double G(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }
    tarch::la::Vector<DIMENSIONS,double> G(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][0+row],_F[1][0+row],_F[2][0+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<6,DIMENSIONS,double> G() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][0+0],_F[1][0+0],
_F[0][0+1],_F[1][0+1],
_F[0][0+2],_F[1][0+2],
_F[0][0+3],_F[1][0+3],
_F[0][0+4],_F[1][0+4],
_F[0][0+5],_F[1][0+5];
      #elif DIMENSIONS==3
      values = 
_F[0][0+0],_F[1][0+0],_F[2][0+0],
_F[0][0+1],_F[1][0+1],_F[2][0+1],
_F[0][0+2],_F[1][0+2],_F[2][0+2],
_F[0][0+3],_F[1][0+3],_F[2][0+3],
_F[0][0+4],_F[1][0+4],_F[2][0+4],
_F[0][0+5],_F[1][0+5],_F[2][0+5];
      #endif
      return values;
    }
    // setters for G
    double& G(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][0+row];
    }

    void G(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][0+0] = values(0,0);
      _F[0][0+1] = values(1,0);
      _F[0][0+2] = values(2,0);
      _F[0][0+3] = values(3,0);
      _F[0][0+4] = values(4,0);
      _F[0][0+5] = values(5,0);
      _F[1][0+0] = values(0,1);
      _F[1][0+1] = values(1,1);
      _F[1][0+2] = values(2,1);
      _F[1][0+3] = values(3,1);
      _F[1][0+4] = values(4,1);
      _F[1][0+5] = values(5,1);
      #if DIMENSIONS==3
      _F[2][0+0] = values(0,2);
      _F[2][0+1] = values(1,2);
      _F[2][0+2] = values(2,2);
      _F[2][0+3] = values(3,2);
      _F[2][0+4] = values(4,2);
      _F[2][0+5] = values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void G(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][0+0] = values(0,0);
      _F[0][0+1] = values(1,0);
      _F[0][0+2] = values(2,0);
      _F[0][0+3] = values(3,0);
      _F[0][0+4] = values(4,0);
      _F[0][0+5] = values(5,0);
      _F[1][0+0] = values(0,1);
      _F[1][0+1] = values(1,1);
      _F[1][0+2] = values(2,1);
      _F[1][0+3] = values(3,1);
      _F[1][0+4] = values(4,1);
      _F[1][0+5] = values(5,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void G(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][0+row] = v0;
      _F[1][0+row] = v1;
      #if DIMENSIONS==3
      _F[2][0+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void G(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][0+row] = v0;
      _F[1][0+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void G(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22,double v30,double v31,double v32,double v40,double v41,double v42,double v50,double v51,double v52) {
      _F[0][0+0] = v00;
      _F[0][0+1] = v10;
      _F[0][0+2] = v20;
      _F[0][0+3] = v30;
      _F[0][0+4] = v40;
      _F[0][0+5] = v50;
      _F[1][0+0] = v01;
      _F[1][0+1] = v11;
      _F[1][0+2] = v21;
      _F[1][0+3] = v31;
      _F[1][0+4] = v41;
      _F[1][0+5] = v51;
      #if DIMENSIONS==3
      _F[2][0+0] = v02;
      _F[2][0+1] = v12;
      _F[2][0+2] = v22;
      _F[2][0+3] = v32;
      _F[2][0+4] = v42;
      _F[2][0+5] = v52;
      #endif
    }
    #if DIMENSIONS==2
    void G(double v00,double v01,double v10,double v11,double v20,double v21,double v30,double v31,double v40,double v41,double v50,double v51) {
      _F[0][0+0] = v00;
      _F[0][0+1] = v10;
      _F[0][0+2] = v20;
      _F[0][0+3] = v30;
      _F[0][0+4] = v40;
      _F[0][0+5] = v50;
      _F[1][0+0] = v01;
      _F[1][0+1] = v11;
      _F[1][0+2] = v21;
      _F[1][0+3] = v31;
      _F[1][0+4] = v41;
      _F[1][0+5] = v51;
    }
    #endif
    // getters for K
    double K(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][6+row];
    }
    tarch::la::Vector<DIMENSIONS,double> K(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][6+row],_F[1][6+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][6+row],_F[1][6+row],_F[2][6+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<6,DIMENSIONS,double> K() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][6+0],_F[1][6+0],
_F[0][6+1],_F[1][6+1],
_F[0][6+2],_F[1][6+2],
_F[0][6+3],_F[1][6+3],
_F[0][6+4],_F[1][6+4],
_F[0][6+5],_F[1][6+5];
      #elif DIMENSIONS==3
      values = 
_F[0][6+0],_F[1][6+0],_F[2][6+0],
_F[0][6+1],_F[1][6+1],_F[2][6+1],
_F[0][6+2],_F[1][6+2],_F[2][6+2],
_F[0][6+3],_F[1][6+3],_F[2][6+3],
_F[0][6+4],_F[1][6+4],_F[2][6+4],
_F[0][6+5],_F[1][6+5],_F[2][6+5];
      #endif
      return values;
    }
    // setters for K
    double& K(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][6+row];
    }

    void K(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][6+0] = values(0,0);
      _F[0][6+1] = values(1,0);
      _F[0][6+2] = values(2,0);
      _F[0][6+3] = values(3,0);
      _F[0][6+4] = values(4,0);
      _F[0][6+5] = values(5,0);
      _F[1][6+0] = values(0,1);
      _F[1][6+1] = values(1,1);
      _F[1][6+2] = values(2,1);
      _F[1][6+3] = values(3,1);
      _F[1][6+4] = values(4,1);
      _F[1][6+5] = values(5,1);
      #if DIMENSIONS==3
      _F[2][6+0] = values(0,2);
      _F[2][6+1] = values(1,2);
      _F[2][6+2] = values(2,2);
      _F[2][6+3] = values(3,2);
      _F[2][6+4] = values(4,2);
      _F[2][6+5] = values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void K(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][6+0] = values(0,0);
      _F[0][6+1] = values(1,0);
      _F[0][6+2] = values(2,0);
      _F[0][6+3] = values(3,0);
      _F[0][6+4] = values(4,0);
      _F[0][6+5] = values(5,0);
      _F[1][6+0] = values(0,1);
      _F[1][6+1] = values(1,1);
      _F[1][6+2] = values(2,1);
      _F[1][6+3] = values(3,1);
      _F[1][6+4] = values(4,1);
      _F[1][6+5] = values(5,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void K(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][6+row] = v0;
      _F[1][6+row] = v1;
      #if DIMENSIONS==3
      _F[2][6+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void K(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][6+row] = v0;
      _F[1][6+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void K(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22,double v30,double v31,double v32,double v40,double v41,double v42,double v50,double v51,double v52) {
      _F[0][6+0] = v00;
      _F[0][6+1] = v10;
      _F[0][6+2] = v20;
      _F[0][6+3] = v30;
      _F[0][6+4] = v40;
      _F[0][6+5] = v50;
      _F[1][6+0] = v01;
      _F[1][6+1] = v11;
      _F[1][6+2] = v21;
      _F[1][6+3] = v31;
      _F[1][6+4] = v41;
      _F[1][6+5] = v51;
      #if DIMENSIONS==3
      _F[2][6+0] = v02;
      _F[2][6+1] = v12;
      _F[2][6+2] = v22;
      _F[2][6+3] = v32;
      _F[2][6+4] = v42;
      _F[2][6+5] = v52;
      #endif
    }
    #if DIMENSIONS==2
    void K(double v00,double v01,double v10,double v11,double v20,double v21,double v30,double v31,double v40,double v41,double v50,double v51) {
      _F[0][6+0] = v00;
      _F[0][6+1] = v10;
      _F[0][6+2] = v20;
      _F[0][6+3] = v30;
      _F[0][6+4] = v40;
      _F[0][6+5] = v50;
      _F[1][6+0] = v01;
      _F[1][6+1] = v11;
      _F[1][6+2] = v21;
      _F[1][6+3] = v31;
      _F[1][6+4] = v41;
      _F[1][6+5] = v51;
    }
    #endif
    // getters for theta
    double theta(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][12];
    }
    tarch::la::Vector<DIMENSIONS,double> theta() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][12],_F[1][12]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][12],_F[1][12],_F[2][12]);
      #endif
      return values;
    }
    // setters for theta
    double& theta(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][12];
    }

    void theta(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][12] = values[0];
      _F[1][12] = values[1];
      #if DIMENSIONS==3
      _F[2][12] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void theta(const tarch::la::Vector<3,double>& values) {
      _F[0][12] = values[0];
      _F[1][12] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void theta(double v0,double v1,double v2) {
      _F[0][12] = v0;
      _F[1][12] = v1;
      #if DIMENSIONS==3
      _F[2][12] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void theta(double v0,double v1) {
      _F[0][12] = v0;
      _F[1][12] = v1;
    }
    #endif
    // getters for Z
    double Z(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }
    tarch::la::Vector<DIMENSIONS,double> Z(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][13+row],_F[1][13+row],_F[2][13+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> Z() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][13+0],_F[1][13+0],
_F[0][13+1],_F[1][13+1],
_F[0][13+2],_F[1][13+2];
      #elif DIMENSIONS==3
      values = 
_F[0][13+0],_F[1][13+0],_F[2][13+0],
_F[0][13+1],_F[1][13+1],_F[2][13+1],
_F[0][13+2],_F[1][13+2],_F[2][13+2];
      #endif
      return values;
    }
    // setters for Z
    double& Z(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][13+row];
    }

    void Z(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][13+0] = values(0,0);
      _F[0][13+1] = values(1,0);
      _F[0][13+2] = values(2,0);
      _F[1][13+0] = values(0,1);
      _F[1][13+1] = values(1,1);
      _F[1][13+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][13+0] = values(0,2);
      _F[2][13+1] = values(1,2);
      _F[2][13+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void Z(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][13+0] = values(0,0);
      _F[0][13+1] = values(1,0);
      _F[0][13+2] = values(2,0);
      _F[1][13+0] = values(0,1);
      _F[1][13+1] = values(1,1);
      _F[1][13+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void Z(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][13+row] = v0;
      _F[1][13+row] = v1;
      #if DIMENSIONS==3
      _F[2][13+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void Z(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][13+row] = v0;
      _F[1][13+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void Z(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][13+0] = v00;
      _F[0][13+1] = v10;
      _F[0][13+2] = v20;
      _F[1][13+0] = v01;
      _F[1][13+1] = v11;
      _F[1][13+2] = v21;
      #if DIMENSIONS==3
      _F[2][13+0] = v02;
      _F[2][13+1] = v12;
      _F[2][13+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void Z(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][13+0] = v00;
      _F[0][13+1] = v10;
      _F[0][13+2] = v20;
      _F[1][13+0] = v01;
      _F[1][13+1] = v11;
      _F[1][13+2] = v21;
    }
    #endif
    // getters for lapse
    double lapse(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][16];
    }
    tarch::la::Vector<DIMENSIONS,double> lapse() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][16],_F[1][16]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][16],_F[1][16],_F[2][16]);
      #endif
      return values;
    }
    // setters for lapse
    double& lapse(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][16];
    }

    void lapse(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][16] = values[0];
      _F[1][16] = values[1];
      #if DIMENSIONS==3
      _F[2][16] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void lapse(const tarch::la::Vector<3,double>& values) {
      _F[0][16] = values[0];
      _F[1][16] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void lapse(double v0,double v1,double v2) {
      _F[0][16] = v0;
      _F[1][16] = v1;
      #if DIMENSIONS==3
      _F[2][16] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void lapse(double v0,double v1) {
      _F[0][16] = v0;
      _F[1][16] = v1;
    }
    #endif
    // getters for shift
    double shift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][17+row];
    }
    tarch::la::Vector<DIMENSIONS,double> shift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][17+row],_F[1][17+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][17+row],_F[1][17+row],_F[2][17+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> shift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][17+0],_F[1][17+0],
_F[0][17+1],_F[1][17+1],
_F[0][17+2],_F[1][17+2];
      #elif DIMENSIONS==3
      values = 
_F[0][17+0],_F[1][17+0],_F[2][17+0],
_F[0][17+1],_F[1][17+1],_F[2][17+1],
_F[0][17+2],_F[1][17+2],_F[2][17+2];
      #endif
      return values;
    }
    // setters for shift
    double& shift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][17+row];
    }

    void shift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][17+0] = values(0,0);
      _F[0][17+1] = values(1,0);
      _F[0][17+2] = values(2,0);
      _F[1][17+0] = values(0,1);
      _F[1][17+1] = values(1,1);
      _F[1][17+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][17+0] = values(0,2);
      _F[2][17+1] = values(1,2);
      _F[2][17+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void shift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][17+0] = values(0,0);
      _F[0][17+1] = values(1,0);
      _F[0][17+2] = values(2,0);
      _F[1][17+0] = values(0,1);
      _F[1][17+1] = values(1,1);
      _F[1][17+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void shift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][17+row] = v0;
      _F[1][17+row] = v1;
      #if DIMENSIONS==3
      _F[2][17+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void shift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][17+row] = v0;
      _F[1][17+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void shift(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][17+0] = v00;
      _F[0][17+1] = v10;
      _F[0][17+2] = v20;
      _F[1][17+0] = v01;
      _F[1][17+1] = v11;
      _F[1][17+2] = v21;
      #if DIMENSIONS==3
      _F[2][17+0] = v02;
      _F[2][17+1] = v12;
      _F[2][17+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void shift(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][17+0] = v00;
      _F[0][17+1] = v10;
      _F[0][17+2] = v20;
      _F[1][17+0] = v01;
      _F[1][17+1] = v11;
      _F[1][17+2] = v21;
    }
    #endif
    // getters for b
    double b(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][20+row];
    }
    tarch::la::Vector<DIMENSIONS,double> b(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][20+row],_F[1][20+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][20+row],_F[1][20+row],_F[2][20+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> b() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][20+0],_F[1][20+0],
_F[0][20+1],_F[1][20+1],
_F[0][20+2],_F[1][20+2];
      #elif DIMENSIONS==3
      values = 
_F[0][20+0],_F[1][20+0],_F[2][20+0],
_F[0][20+1],_F[1][20+1],_F[2][20+1],
_F[0][20+2],_F[1][20+2],_F[2][20+2];
      #endif
      return values;
    }
    // setters for b
    double& b(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][20+row];
    }

    void b(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][20+0] = values(0,0);
      _F[0][20+1] = values(1,0);
      _F[0][20+2] = values(2,0);
      _F[1][20+0] = values(0,1);
      _F[1][20+1] = values(1,1);
      _F[1][20+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][20+0] = values(0,2);
      _F[2][20+1] = values(1,2);
      _F[2][20+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void b(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][20+0] = values(0,0);
      _F[0][20+1] = values(1,0);
      _F[0][20+2] = values(2,0);
      _F[1][20+0] = values(0,1);
      _F[1][20+1] = values(1,1);
      _F[1][20+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void b(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][20+row] = v0;
      _F[1][20+row] = v1;
      #if DIMENSIONS==3
      _F[2][20+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void b(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][20+row] = v0;
      _F[1][20+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void b(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][20+0] = v00;
      _F[0][20+1] = v10;
      _F[0][20+2] = v20;
      _F[1][20+0] = v01;
      _F[1][20+1] = v11;
      _F[1][20+2] = v21;
      #if DIMENSIONS==3
      _F[2][20+0] = v02;
      _F[2][20+1] = v12;
      _F[2][20+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void b(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][20+0] = v00;
      _F[0][20+1] = v10;
      _F[0][20+2] = v20;
      _F[1][20+0] = v01;
      _F[1][20+1] = v11;
      _F[1][20+2] = v21;
    }
    #endif
    // getters for dLapse
    double dLapse(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][23+row];
    }
    tarch::la::Vector<DIMENSIONS,double> dLapse(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][23+row],_F[1][23+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][23+row],_F[1][23+row],_F[2][23+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> dLapse() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][23+0],_F[1][23+0],
_F[0][23+1],_F[1][23+1],
_F[0][23+2],_F[1][23+2];
      #elif DIMENSIONS==3
      values = 
_F[0][23+0],_F[1][23+0],_F[2][23+0],
_F[0][23+1],_F[1][23+1],_F[2][23+1],
_F[0][23+2],_F[1][23+2],_F[2][23+2];
      #endif
      return values;
    }
    // setters for dLapse
    double& dLapse(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][23+row];
    }

    void dLapse(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][23+0] = values(0,0);
      _F[0][23+1] = values(1,0);
      _F[0][23+2] = values(2,0);
      _F[1][23+0] = values(0,1);
      _F[1][23+1] = values(1,1);
      _F[1][23+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][23+0] = values(0,2);
      _F[2][23+1] = values(1,2);
      _F[2][23+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void dLapse(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][23+0] = values(0,0);
      _F[0][23+1] = values(1,0);
      _F[0][23+2] = values(2,0);
      _F[1][23+0] = values(0,1);
      _F[1][23+1] = values(1,1);
      _F[1][23+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void dLapse(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][23+row] = v0;
      _F[1][23+row] = v1;
      #if DIMENSIONS==3
      _F[2][23+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void dLapse(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][23+row] = v0;
      _F[1][23+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void dLapse(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][23+0] = v00;
      _F[0][23+1] = v10;
      _F[0][23+2] = v20;
      _F[1][23+0] = v01;
      _F[1][23+1] = v11;
      _F[1][23+2] = v21;
      #if DIMENSIONS==3
      _F[2][23+0] = v02;
      _F[2][23+1] = v12;
      _F[2][23+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void dLapse(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][23+0] = v00;
      _F[0][23+1] = v10;
      _F[0][23+2] = v20;
      _F[1][23+0] = v01;
      _F[1][23+1] = v11;
      _F[1][23+2] = v21;
    }
    #endif
    // getters for dxShift
    double dxShift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][26+row];
    }
    tarch::la::Vector<DIMENSIONS,double> dxShift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][26+row],_F[1][26+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][26+row],_F[1][26+row],_F[2][26+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> dxShift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][26+0],_F[1][26+0],
_F[0][26+1],_F[1][26+1],
_F[0][26+2],_F[1][26+2];
      #elif DIMENSIONS==3
      values = 
_F[0][26+0],_F[1][26+0],_F[2][26+0],
_F[0][26+1],_F[1][26+1],_F[2][26+1],
_F[0][26+2],_F[1][26+2],_F[2][26+2];
      #endif
      return values;
    }
    // setters for dxShift
    double& dxShift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][26+row];
    }

    void dxShift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][26+0] = values(0,0);
      _F[0][26+1] = values(1,0);
      _F[0][26+2] = values(2,0);
      _F[1][26+0] = values(0,1);
      _F[1][26+1] = values(1,1);
      _F[1][26+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][26+0] = values(0,2);
      _F[2][26+1] = values(1,2);
      _F[2][26+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void dxShift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][26+0] = values(0,0);
      _F[0][26+1] = values(1,0);
      _F[0][26+2] = values(2,0);
      _F[1][26+0] = values(0,1);
      _F[1][26+1] = values(1,1);
      _F[1][26+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void dxShift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][26+row] = v0;
      _F[1][26+row] = v1;
      #if DIMENSIONS==3
      _F[2][26+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void dxShift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][26+row] = v0;
      _F[1][26+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void dxShift(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][26+0] = v00;
      _F[0][26+1] = v10;
      _F[0][26+2] = v20;
      _F[1][26+0] = v01;
      _F[1][26+1] = v11;
      _F[1][26+2] = v21;
      #if DIMENSIONS==3
      _F[2][26+0] = v02;
      _F[2][26+1] = v12;
      _F[2][26+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void dxShift(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][26+0] = v00;
      _F[0][26+1] = v10;
      _F[0][26+2] = v20;
      _F[1][26+0] = v01;
      _F[1][26+1] = v11;
      _F[1][26+2] = v21;
    }
    #endif
    // getters for dyShift
    double dyShift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][29+row];
    }
    tarch::la::Vector<DIMENSIONS,double> dyShift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][29+row],_F[1][29+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][29+row],_F[1][29+row],_F[2][29+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> dyShift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][29+0],_F[1][29+0],
_F[0][29+1],_F[1][29+1],
_F[0][29+2],_F[1][29+2];
      #elif DIMENSIONS==3
      values = 
_F[0][29+0],_F[1][29+0],_F[2][29+0],
_F[0][29+1],_F[1][29+1],_F[2][29+1],
_F[0][29+2],_F[1][29+2],_F[2][29+2];
      #endif
      return values;
    }
    // setters for dyShift
    double& dyShift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][29+row];
    }

    void dyShift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][29+0] = values(0,0);
      _F[0][29+1] = values(1,0);
      _F[0][29+2] = values(2,0);
      _F[1][29+0] = values(0,1);
      _F[1][29+1] = values(1,1);
      _F[1][29+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][29+0] = values(0,2);
      _F[2][29+1] = values(1,2);
      _F[2][29+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void dyShift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][29+0] = values(0,0);
      _F[0][29+1] = values(1,0);
      _F[0][29+2] = values(2,0);
      _F[1][29+0] = values(0,1);
      _F[1][29+1] = values(1,1);
      _F[1][29+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void dyShift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][29+row] = v0;
      _F[1][29+row] = v1;
      #if DIMENSIONS==3
      _F[2][29+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void dyShift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][29+row] = v0;
      _F[1][29+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void dyShift(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][29+0] = v00;
      _F[0][29+1] = v10;
      _F[0][29+2] = v20;
      _F[1][29+0] = v01;
      _F[1][29+1] = v11;
      _F[1][29+2] = v21;
      #if DIMENSIONS==3
      _F[2][29+0] = v02;
      _F[2][29+1] = v12;
      _F[2][29+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void dyShift(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][29+0] = v00;
      _F[0][29+1] = v10;
      _F[0][29+2] = v20;
      _F[1][29+0] = v01;
      _F[1][29+1] = v11;
      _F[1][29+2] = v21;
    }
    #endif
    // getters for dzShift
    double dzShift(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][32+row];
    }
    tarch::la::Vector<DIMENSIONS,double> dzShift(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][32+row],_F[1][32+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][32+row],_F[1][32+row],_F[2][32+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> dzShift() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][32+0],_F[1][32+0],
_F[0][32+1],_F[1][32+1],
_F[0][32+2],_F[1][32+2];
      #elif DIMENSIONS==3
      values = 
_F[0][32+0],_F[1][32+0],_F[2][32+0],
_F[0][32+1],_F[1][32+1],_F[2][32+1],
_F[0][32+2],_F[1][32+2],_F[2][32+2];
      #endif
      return values;
    }
    // setters for dzShift
    double& dzShift(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][32+row];
    }

    void dzShift(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][32+0] = values(0,0);
      _F[0][32+1] = values(1,0);
      _F[0][32+2] = values(2,0);
      _F[1][32+0] = values(0,1);
      _F[1][32+1] = values(1,1);
      _F[1][32+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][32+0] = values(0,2);
      _F[2][32+1] = values(1,2);
      _F[2][32+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void dzShift(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][32+0] = values(0,0);
      _F[0][32+1] = values(1,0);
      _F[0][32+2] = values(2,0);
      _F[1][32+0] = values(0,1);
      _F[1][32+1] = values(1,1);
      _F[1][32+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void dzShift(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][32+row] = v0;
      _F[1][32+row] = v1;
      #if DIMENSIONS==3
      _F[2][32+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void dzShift(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][32+row] = v0;
      _F[1][32+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void dzShift(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][32+0] = v00;
      _F[0][32+1] = v10;
      _F[0][32+2] = v20;
      _F[1][32+0] = v01;
      _F[1][32+1] = v11;
      _F[1][32+2] = v21;
      #if DIMENSIONS==3
      _F[2][32+0] = v02;
      _F[2][32+1] = v12;
      _F[2][32+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void dzShift(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][32+0] = v00;
      _F[0][32+1] = v10;
      _F[0][32+2] = v20;
      _F[1][32+0] = v01;
      _F[1][32+1] = v11;
      _F[1][32+2] = v21;
    }
    #endif
    // getters for dxG
    double dxG(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][35+row];
    }
    tarch::la::Vector<DIMENSIONS,double> dxG(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][35+row],_F[1][35+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][35+row],_F[1][35+row],_F[2][35+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<6,DIMENSIONS,double> dxG() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][35+0],_F[1][35+0],
_F[0][35+1],_F[1][35+1],
_F[0][35+2],_F[1][35+2],
_F[0][35+3],_F[1][35+3],
_F[0][35+4],_F[1][35+4],
_F[0][35+5],_F[1][35+5];
      #elif DIMENSIONS==3
      values = 
_F[0][35+0],_F[1][35+0],_F[2][35+0],
_F[0][35+1],_F[1][35+1],_F[2][35+1],
_F[0][35+2],_F[1][35+2],_F[2][35+2],
_F[0][35+3],_F[1][35+3],_F[2][35+3],
_F[0][35+4],_F[1][35+4],_F[2][35+4],
_F[0][35+5],_F[1][35+5],_F[2][35+5];
      #endif
      return values;
    }
    // setters for dxG
    double& dxG(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][35+row];
    }

    void dxG(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][35+0] = values(0,0);
      _F[0][35+1] = values(1,0);
      _F[0][35+2] = values(2,0);
      _F[0][35+3] = values(3,0);
      _F[0][35+4] = values(4,0);
      _F[0][35+5] = values(5,0);
      _F[1][35+0] = values(0,1);
      _F[1][35+1] = values(1,1);
      _F[1][35+2] = values(2,1);
      _F[1][35+3] = values(3,1);
      _F[1][35+4] = values(4,1);
      _F[1][35+5] = values(5,1);
      #if DIMENSIONS==3
      _F[2][35+0] = values(0,2);
      _F[2][35+1] = values(1,2);
      _F[2][35+2] = values(2,2);
      _F[2][35+3] = values(3,2);
      _F[2][35+4] = values(4,2);
      _F[2][35+5] = values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void dxG(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][35+0] = values(0,0);
      _F[0][35+1] = values(1,0);
      _F[0][35+2] = values(2,0);
      _F[0][35+3] = values(3,0);
      _F[0][35+4] = values(4,0);
      _F[0][35+5] = values(5,0);
      _F[1][35+0] = values(0,1);
      _F[1][35+1] = values(1,1);
      _F[1][35+2] = values(2,1);
      _F[1][35+3] = values(3,1);
      _F[1][35+4] = values(4,1);
      _F[1][35+5] = values(5,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void dxG(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][35+row] = v0;
      _F[1][35+row] = v1;
      #if DIMENSIONS==3
      _F[2][35+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void dxG(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][35+row] = v0;
      _F[1][35+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void dxG(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22,double v30,double v31,double v32,double v40,double v41,double v42,double v50,double v51,double v52) {
      _F[0][35+0] = v00;
      _F[0][35+1] = v10;
      _F[0][35+2] = v20;
      _F[0][35+3] = v30;
      _F[0][35+4] = v40;
      _F[0][35+5] = v50;
      _F[1][35+0] = v01;
      _F[1][35+1] = v11;
      _F[1][35+2] = v21;
      _F[1][35+3] = v31;
      _F[1][35+4] = v41;
      _F[1][35+5] = v51;
      #if DIMENSIONS==3
      _F[2][35+0] = v02;
      _F[2][35+1] = v12;
      _F[2][35+2] = v22;
      _F[2][35+3] = v32;
      _F[2][35+4] = v42;
      _F[2][35+5] = v52;
      #endif
    }
    #if DIMENSIONS==2
    void dxG(double v00,double v01,double v10,double v11,double v20,double v21,double v30,double v31,double v40,double v41,double v50,double v51) {
      _F[0][35+0] = v00;
      _F[0][35+1] = v10;
      _F[0][35+2] = v20;
      _F[0][35+3] = v30;
      _F[0][35+4] = v40;
      _F[0][35+5] = v50;
      _F[1][35+0] = v01;
      _F[1][35+1] = v11;
      _F[1][35+2] = v21;
      _F[1][35+3] = v31;
      _F[1][35+4] = v41;
      _F[1][35+5] = v51;
    }
    #endif
    // getters for dyG
    double dyG(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][41+row];
    }
    tarch::la::Vector<DIMENSIONS,double> dyG(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][41+row],_F[1][41+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][41+row],_F[1][41+row],_F[2][41+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<6,DIMENSIONS,double> dyG() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][41+0],_F[1][41+0],
_F[0][41+1],_F[1][41+1],
_F[0][41+2],_F[1][41+2],
_F[0][41+3],_F[1][41+3],
_F[0][41+4],_F[1][41+4],
_F[0][41+5],_F[1][41+5];
      #elif DIMENSIONS==3
      values = 
_F[0][41+0],_F[1][41+0],_F[2][41+0],
_F[0][41+1],_F[1][41+1],_F[2][41+1],
_F[0][41+2],_F[1][41+2],_F[2][41+2],
_F[0][41+3],_F[1][41+3],_F[2][41+3],
_F[0][41+4],_F[1][41+4],_F[2][41+4],
_F[0][41+5],_F[1][41+5],_F[2][41+5];
      #endif
      return values;
    }
    // setters for dyG
    double& dyG(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][41+row];
    }

    void dyG(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][41+0] = values(0,0);
      _F[0][41+1] = values(1,0);
      _F[0][41+2] = values(2,0);
      _F[0][41+3] = values(3,0);
      _F[0][41+4] = values(4,0);
      _F[0][41+5] = values(5,0);
      _F[1][41+0] = values(0,1);
      _F[1][41+1] = values(1,1);
      _F[1][41+2] = values(2,1);
      _F[1][41+3] = values(3,1);
      _F[1][41+4] = values(4,1);
      _F[1][41+5] = values(5,1);
      #if DIMENSIONS==3
      _F[2][41+0] = values(0,2);
      _F[2][41+1] = values(1,2);
      _F[2][41+2] = values(2,2);
      _F[2][41+3] = values(3,2);
      _F[2][41+4] = values(4,2);
      _F[2][41+5] = values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void dyG(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][41+0] = values(0,0);
      _F[0][41+1] = values(1,0);
      _F[0][41+2] = values(2,0);
      _F[0][41+3] = values(3,0);
      _F[0][41+4] = values(4,0);
      _F[0][41+5] = values(5,0);
      _F[1][41+0] = values(0,1);
      _F[1][41+1] = values(1,1);
      _F[1][41+2] = values(2,1);
      _F[1][41+3] = values(3,1);
      _F[1][41+4] = values(4,1);
      _F[1][41+5] = values(5,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void dyG(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][41+row] = v0;
      _F[1][41+row] = v1;
      #if DIMENSIONS==3
      _F[2][41+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void dyG(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][41+row] = v0;
      _F[1][41+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void dyG(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22,double v30,double v31,double v32,double v40,double v41,double v42,double v50,double v51,double v52) {
      _F[0][41+0] = v00;
      _F[0][41+1] = v10;
      _F[0][41+2] = v20;
      _F[0][41+3] = v30;
      _F[0][41+4] = v40;
      _F[0][41+5] = v50;
      _F[1][41+0] = v01;
      _F[1][41+1] = v11;
      _F[1][41+2] = v21;
      _F[1][41+3] = v31;
      _F[1][41+4] = v41;
      _F[1][41+5] = v51;
      #if DIMENSIONS==3
      _F[2][41+0] = v02;
      _F[2][41+1] = v12;
      _F[2][41+2] = v22;
      _F[2][41+3] = v32;
      _F[2][41+4] = v42;
      _F[2][41+5] = v52;
      #endif
    }
    #if DIMENSIONS==2
    void dyG(double v00,double v01,double v10,double v11,double v20,double v21,double v30,double v31,double v40,double v41,double v50,double v51) {
      _F[0][41+0] = v00;
      _F[0][41+1] = v10;
      _F[0][41+2] = v20;
      _F[0][41+3] = v30;
      _F[0][41+4] = v40;
      _F[0][41+5] = v50;
      _F[1][41+0] = v01;
      _F[1][41+1] = v11;
      _F[1][41+2] = v21;
      _F[1][41+3] = v31;
      _F[1][41+4] = v41;
      _F[1][41+5] = v51;
    }
    #endif
    // getters for dzG
    double dzG(int row, int column) const {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][47+row];
    }
    tarch::la::Vector<DIMENSIONS,double> dzG(int row) const {
      assertion(row >= 0 && row<6);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][47+row],_F[1][47+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][47+row],_F[1][47+row],_F[2][47+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<6,DIMENSIONS,double> dzG() const {
      tarch::la::Matrix<6,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][47+0],_F[1][47+0],
_F[0][47+1],_F[1][47+1],
_F[0][47+2],_F[1][47+2],
_F[0][47+3],_F[1][47+3],
_F[0][47+4],_F[1][47+4],
_F[0][47+5],_F[1][47+5];
      #elif DIMENSIONS==3
      values = 
_F[0][47+0],_F[1][47+0],_F[2][47+0],
_F[0][47+1],_F[1][47+1],_F[2][47+1],
_F[0][47+2],_F[1][47+2],_F[2][47+2],
_F[0][47+3],_F[1][47+3],_F[2][47+3],
_F[0][47+4],_F[1][47+4],_F[2][47+4],
_F[0][47+5],_F[1][47+5],_F[2][47+5];
      #endif
      return values;
    }
    // setters for dzG
    double& dzG(int row, int column) {
      assertion(row >= 0 && row<6);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][47+row];
    }

    void dzG(const tarch::la::Matrix<6,DIMENSIONS,double>& values) {
      _F[0][47+0] = values(0,0);
      _F[0][47+1] = values(1,0);
      _F[0][47+2] = values(2,0);
      _F[0][47+3] = values(3,0);
      _F[0][47+4] = values(4,0);
      _F[0][47+5] = values(5,0);
      _F[1][47+0] = values(0,1);
      _F[1][47+1] = values(1,1);
      _F[1][47+2] = values(2,1);
      _F[1][47+3] = values(3,1);
      _F[1][47+4] = values(4,1);
      _F[1][47+5] = values(5,1);
      #if DIMENSIONS==3
      _F[2][47+0] = values(0,2);
      _F[2][47+1] = values(1,2);
      _F[2][47+2] = values(2,2);
      _F[2][47+3] = values(3,2);
      _F[2][47+4] = values(4,2);
      _F[2][47+5] = values(5,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void dzG(const tarch::la::Matrix<6,3,double>& values) {
      _F[0][47+0] = values(0,0);
      _F[0][47+1] = values(1,0);
      _F[0][47+2] = values(2,0);
      _F[0][47+3] = values(3,0);
      _F[0][47+4] = values(4,0);
      _F[0][47+5] = values(5,0);
      _F[1][47+0] = values(0,1);
      _F[1][47+1] = values(1,1);
      _F[1][47+2] = values(2,1);
      _F[1][47+3] = values(3,1);
      _F[1][47+4] = values(4,1);
      _F[1][47+5] = values(5,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void dzG(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<6);
      _F[0][47+row] = v0;
      _F[1][47+row] = v1;
      #if DIMENSIONS==3
      _F[2][47+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void dzG(int row, double v0,double v1) {
      assertion(row >= 0 && row<6);
      _F[0][47+row] = v0;
      _F[1][47+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void dzG(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22,double v30,double v31,double v32,double v40,double v41,double v42,double v50,double v51,double v52) {
      _F[0][47+0] = v00;
      _F[0][47+1] = v10;
      _F[0][47+2] = v20;
      _F[0][47+3] = v30;
      _F[0][47+4] = v40;
      _F[0][47+5] = v50;
      _F[1][47+0] = v01;
      _F[1][47+1] = v11;
      _F[1][47+2] = v21;
      _F[1][47+3] = v31;
      _F[1][47+4] = v41;
      _F[1][47+5] = v51;
      #if DIMENSIONS==3
      _F[2][47+0] = v02;
      _F[2][47+1] = v12;
      _F[2][47+2] = v22;
      _F[2][47+3] = v32;
      _F[2][47+4] = v42;
      _F[2][47+5] = v52;
      #endif
    }
    #if DIMENSIONS==2
    void dzG(double v00,double v01,double v10,double v11,double v20,double v21,double v30,double v31,double v40,double v41,double v50,double v51) {
      _F[0][47+0] = v00;
      _F[0][47+1] = v10;
      _F[0][47+2] = v20;
      _F[0][47+3] = v30;
      _F[0][47+4] = v40;
      _F[0][47+5] = v50;
      _F[1][47+0] = v01;
      _F[1][47+1] = v11;
      _F[1][47+2] = v21;
      _F[1][47+3] = v31;
      _F[1][47+4] = v41;
      _F[1][47+5] = v51;
    }
    #endif
    // getters for traceK
    double traceK(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][53];
    }
    tarch::la::Vector<DIMENSIONS,double> traceK() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][53],_F[1][53]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][53],_F[1][53],_F[2][53]);
      #endif
      return values;
    }
    // setters for traceK
    double& traceK(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][53];
    }

    void traceK(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][53] = values[0];
      _F[1][53] = values[1];
      #if DIMENSIONS==3
      _F[2][53] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void traceK(const tarch::la::Vector<3,double>& values) {
      _F[0][53] = values[0];
      _F[1][53] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void traceK(double v0,double v1,double v2) {
      _F[0][53] = v0;
      _F[1][53] = v1;
      #if DIMENSIONS==3
      _F[2][53] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void traceK(double v0,double v1) {
      _F[0][53] = v0;
      _F[1][53] = v1;
    }
    #endif
    // getters for phi
    double phi(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][54];
    }
    tarch::la::Vector<DIMENSIONS,double> phi() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][54],_F[1][54]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][54],_F[1][54],_F[2][54]);
      #endif
      return values;
    }
    // setters for phi
    double& phi(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][54];
    }

    void phi(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][54] = values[0];
      _F[1][54] = values[1];
      #if DIMENSIONS==3
      _F[2][54] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void phi(const tarch::la::Vector<3,double>& values) {
      _F[0][54] = values[0];
      _F[1][54] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void phi(double v0,double v1,double v2) {
      _F[0][54] = v0;
      _F[1][54] = v1;
      #if DIMENSIONS==3
      _F[2][54] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void phi(double v0,double v1) {
      _F[0][54] = v0;
      _F[1][54] = v1;
    }
    #endif
    // getters for P
    double P(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][55+row];
    }
    tarch::la::Vector<DIMENSIONS,double> P(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][55+row],_F[1][55+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][55+row],_F[1][55+row],_F[2][55+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> P() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][55+0],_F[1][55+0],
_F[0][55+1],_F[1][55+1],
_F[0][55+2],_F[1][55+2];
      #elif DIMENSIONS==3
      values = 
_F[0][55+0],_F[1][55+0],_F[2][55+0],
_F[0][55+1],_F[1][55+1],_F[2][55+1],
_F[0][55+2],_F[1][55+2],_F[2][55+2];
      #endif
      return values;
    }
    // setters for P
    double& P(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][55+row];
    }

    void P(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][55+0] = values(0,0);
      _F[0][55+1] = values(1,0);
      _F[0][55+2] = values(2,0);
      _F[1][55+0] = values(0,1);
      _F[1][55+1] = values(1,1);
      _F[1][55+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][55+0] = values(0,2);
      _F[2][55+1] = values(1,2);
      _F[2][55+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void P(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][55+0] = values(0,0);
      _F[0][55+1] = values(1,0);
      _F[0][55+2] = values(2,0);
      _F[1][55+0] = values(0,1);
      _F[1][55+1] = values(1,1);
      _F[1][55+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void P(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][55+row] = v0;
      _F[1][55+row] = v1;
      #if DIMENSIONS==3
      _F[2][55+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void P(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][55+row] = v0;
      _F[1][55+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void P(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][55+0] = v00;
      _F[0][55+1] = v10;
      _F[0][55+2] = v20;
      _F[1][55+0] = v01;
      _F[1][55+1] = v11;
      _F[1][55+2] = v21;
      #if DIMENSIONS==3
      _F[2][55+0] = v02;
      _F[2][55+1] = v12;
      _F[2][55+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void P(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][55+0] = v00;
      _F[0][55+1] = v10;
      _F[0][55+2] = v20;
      _F[1][55+0] = v01;
      _F[1][55+1] = v11;
      _F[1][55+2] = v21;
    }
    #endif
    // getters for K0
    double K0(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][58];
    }
    tarch::la::Vector<DIMENSIONS,double> K0() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][58],_F[1][58]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][58],_F[1][58],_F[2][58]);
      #endif
      return values;
    }
    // setters for K0
    double& K0(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][58];
    }

    void K0(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][58] = values[0];
      _F[1][58] = values[1];
      #if DIMENSIONS==3
      _F[2][58] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void K0(const tarch::la::Vector<3,double>& values) {
      _F[0][58] = values[0];
      _F[1][58] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void K0(double v0,double v1,double v2) {
      _F[0][58] = v0;
      _F[1][58] = v1;
      #if DIMENSIONS==3
      _F[2][58] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void K0(double v0,double v1) {
      _F[0][58] = v0;
      _F[1][58] = v1;
    }
    #endif
    // getters for domain
    double domain(int column) const {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][59];
    }
    tarch::la::Vector<DIMENSIONS,double> domain() const {
      #if DIMENSIONS==2 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][59],_F[1][59]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][59],_F[1][59],_F[2][59]);
      #endif
      return values;
    }
    // setters for domain
    double& domain(int column) {
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][59];
    }

    void domain(const tarch::la::Vector<DIMENSIONS,double>& values) {
      _F[0][59] = values[0];
      _F[1][59] = values[1];
      #if DIMENSIONS==3
      _F[2][59] = values[2];
      #endif
    }

    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third vector element is ignored.*/;
    void domain(const tarch::la::Vector<3,double>& values) {
      _F[0][59] = values[0];
      _F[1][59] = values[1];
    }
    #endif

    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void domain(double v0,double v1,double v2) {
      _F[0][59] = v0;
      _F[1][59] = v1;
      #if DIMENSIONS==3
      _F[2][59] = v2;
      #endif
    }
    
    #if DIMENSIONS==2
    void domain(double v0,double v1) {
      _F[0][59] = v0;
      _F[1][59] = v1;
    }
    #endif
    // getters for pos
    double pos(int row, int column) const {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][60+row];
    }
    tarch::la::Vector<DIMENSIONS,double> pos(int row) const {
      assertion(row >= 0 && row<3);
      #if DIMENSIONS==2
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][60+row],_F[1][60+row]);
      #elif DIMENSIONS==3 
      tarch::la::Vector<DIMENSIONS,double> values(_F[0][60+row],_F[1][60+row],_F[2][60+row]);
      #endif
      return values;
    }
    tarch::la::Matrix<3,DIMENSIONS,double> pos() const {
      tarch::la::Matrix<3,DIMENSIONS,double> values;
      #if DIMENSIONS==2
      values = 
_F[0][60+0],_F[1][60+0],
_F[0][60+1],_F[1][60+1],
_F[0][60+2],_F[1][60+2];
      #elif DIMENSIONS==3
      values = 
_F[0][60+0],_F[1][60+0],_F[2][60+0],
_F[0][60+1],_F[1][60+1],_F[2][60+1],
_F[0][60+2],_F[1][60+2],_F[2][60+2];
      #endif
      return values;
    }
    // setters for pos
    double& pos(int row, int column) {
      assertion(row >= 0 && row<3);
      assertion(column >= 0 && column<DIMENSIONS);
      return _F[column][60+row];
    }

    void pos(const tarch::la::Matrix<3,DIMENSIONS,double>& values) {
      _F[0][60+0] = values(0,0);
      _F[0][60+1] = values(1,0);
      _F[0][60+2] = values(2,0);
      _F[1][60+0] = values(0,1);
      _F[1][60+1] = values(1,1);
      _F[1][60+2] = values(2,1);
      #if DIMENSIONS==3
      _F[2][60+0] = values(0,2);
      _F[2][60+1] = values(1,2);
      _F[2][60+2] = values(2,2);
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2.5D calculations. Third matrix column is ignored.*/;
    void pos(const tarch::la::Matrix<3,3,double>& values) {
      _F[0][60+0] = values(0,0);
      _F[0][60+1] = values(1,0);
      _F[0][60+2] = values(2,0);
      _F[1][60+0] = values(0,1);
      _F[1][60+1] = values(1,1);
      _F[1][60+2] = values(2,1);
    }
    #endif
      
    // setter for 3D and 2.5D calculations. Third argument is ignored for the latter.
    void pos(int row, double v0,double v1,double v2) {
      assertion(row >= 0 && row<3);
      _F[0][60+row] = v0;
      _F[1][60+row] = v1;
      #if DIMENSIONS==3
      _F[2][60+row] = v2;
      #endif
    }
    #if DIMENSIONS==2
    // setter for 2D calculations.*/;
    void pos(int row, double v0,double v1) {
      assertion(row >= 0 && row<3);
      _F[0][60+row] = v0;
      _F[1][60+row] = v1;
    }
    #endif

    // setter for 3D and 2.5D calculations. Third column values are ignored for the latter.
    void pos(double v00,double v01,double v02,double v10,double v11,double v12,double v20,double v21,double v22) {
      _F[0][60+0] = v00;
      _F[0][60+1] = v10;
      _F[0][60+2] = v20;
      _F[1][60+0] = v01;
      _F[1][60+1] = v11;
      _F[1][60+2] = v21;
      #if DIMENSIONS==3
      _F[2][60+0] = v02;
      _F[2][60+1] = v12;
      _F[2][60+2] = v22;
      #endif
    }
    #if DIMENSIONS==2
    void pos(double v00,double v01,double v10,double v11,double v20,double v21) {
      _F[0][60+0] = v00;
      _F[0][60+1] = v10;
      _F[0][60+2] = v20;
      _F[1][60+0] = v01;
      _F[1][60+1] = v11;
      _F[1][60+2] = v21;
    }
    #endif
}; // end of Fluxes

// NamingSchemes:

//
// Global Observables
//
class CCZ4::AbstractCCZ4Solver_ADERDG::ReadOnlyGlobalObservables {
  private:
    const double* const _observables;
  public:
    static constexpr int Size = 0;
    
    ReadOnlyGlobalObservables(const double* const observables) : _observables(observables) {}
    
    double operator [] (int index) const {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double operator () (int index) const {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    const double* data() const {
      return _observables;
    }
    
    int size() const {
      return Size;
    }

}; // end of ReadOnlyGlobalObservables


class CCZ4::AbstractCCZ4Solver_ADERDG::GlobalObservables {
  private:
    double* const _observables;
  public:
    static constexpr int Size = 0;
  
    GlobalObservables(double* const observables) : _observables(observables) {}
    
    void operator = (GlobalObservables& observables) {
      std::copy(observables.data(),observables.data()+Size,_observables);
    }
    
    void operator = (ReadOnlyGlobalObservables& observables) {
      assertion(observables.size()==Size);
      std::copy(observables.data(),observables.data()+Size,_observables);
    }
    
    double& operator [] (int index) {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double& operator () (int index) {
      assertion(index>=0 && index < Size);
      return _observables[index];
    }
    
    double* data() {
      return _observables;
    }
    
    int size() const {
      return Size;
    }

}; 
// end of GlobalObservables

#endif