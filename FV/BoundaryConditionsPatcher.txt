#! todo: implement

// Here is a small guide for the patching:

/*
 * We will write again a hook which is evaluated by "exa compile" to patch
 * any newly generated AbstractCCZ4Solver_ADERDG.
 * 
 * What you can do to ensure at runtime that the correct BC Code is loaded:
 * 
 * Overwrite (with warning if not successful) the Constructor of one of the solers, i.e

CCZ4::AbstractCCZ4Solver_ADERDG::AbstractCCZ4Solver_ADERDG(
    const double maximumMeshSize,
    const int maximumMeshDepth,
    const int haloCells,
    const int regularisedFineGridLevels,
    const exahype::solvers::Solver::TimeStepping timeStepping,
    const int limiterHelperLayers,
    const int DMPObservables
    )
  :
  exahype::solvers::ADERDGSolver(
      "CCZ4Solver_ADERDG",
      NumberOfVariables,
      NumberOfParameters,
      Order+1,
      maximumMeshSize,
      maximumMeshDepth,
      haloCells,
      regularisedFineGridLevels,
      timeStepping,
      limiterHelperLayers,
      DMPObservables
      ) {
      
      static tarch _log;
      logInfo("CCZ4 PatchWise Boundary Code loaded successfully.");
}


 FURTHERMORE

void CCZ4::AbstractCCZ4Solver_ADERDG::constantsToString(std::ostream& os) {
  // This string is used in the --version output to identify compile time constants
  os << "CCZ4::AbstractCCZ4Solver_ADERDG("
     << "nVar=" << NumberOfVariables << ", "
     << "nParam=" << NumberOfParameters << ", "
     << "Order=" << Order
     << ")";
     
  os << " --- PATCHED for patchwiseBoundary";
}


  AND THEN OF COURSE
  
  
  
void CCZ4::AbstractCCZ4Solver_ADERDG::boundaryConditions(double* const update, double* const fluxIn,const double* const stateIn,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,const double t,const double dt,const int direction,const int orientation) {
  constexpr int basisSize     = (Order+1)*(Order+1);
  constexpr int sizeStateOut = (NumberOfVariables+NumberOfParameters)*basisSize;
  constexpr int sizeFluxOut  = (DIMENSIONS + 1)*NumberOfVariables*basisSize;
  
  constexpr int totalSize = sizeStateOut + sizeFluxOut;
  double* block = new double[totalSize];
  double* memory = block;

  double* stateOut = memory; memory+=sizeStateOut;
  double* fluxOut  = memory; memory+=sizeFluxOut;

  const int faceIndex = 2*direction+orientation;
  
  HERE:
     switch(GLOBAL_BOUNDARY_CONDITION::getCriterion()) {
	     case "Radiative":
		     CCZ4_RadBC::RadiativeBoundaryConditions(fluxOut,stateOut,fluxIn,stateIn,cellCentre,cellSize,t,dt,faceIndex,direction);
		     break;
	     case "Pointwise":
	     case "Exact":
                    kernels::aderdg::generic::c::boundaryConditions<CCZ4Solver_ADERDG>(*static_cast<CCZ4Solver_ADERDG*>(this),fluxOut,stateOut,fluxIn,stateIn,cellCentre,cellSize,t,dt,faceIndex,direction);
                    break;
	     default:
		    throw std::error("Illegal criterion");
     }

  THEN GO ON NORMALLY:
     
  if ( orientation==0 ) {
    double* FL = fluxOut; const double* const QL = stateOut;
    double* FR = fluxIn;  const double* const QR = stateIn;
  
    riemannSolver(FL,FR,QL,QR,dt,direction,true,faceIndex);
  
    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(update,fluxIn,direction,orientation,cellSize);
  }
  else {
    double* FL = fluxIn;  const double* const QL = stateIn;
    double* FR = fluxOut; const double* const QR = stateOut;

    riemannSolver(FL,FR,QL,QR,dt,direction,true,faceIndex);
    
    kernels::aderdg::generic::c::faceIntegralNonlinear<NumberOfVariables, Order+1>(update,fluxIn,direction,orientation,cellSize);
  }
  delete[] block;
}




 ---> BIG BIG Question mark, keep in mind:
 
    Should we implement the BC also for the FV solver?
    I would *not* do it (as we do not have the neat DG derivatives -- or we have to project them back on our own!)
    and ensure by postprocessing visualization that limiting did NOT take place at the boundary.
    
    This is risky because we *know* that Limiting likes to take place at the boundary!
    
    If we would like to implement the BC code for FV, then we need to fill ghost cells. This is a completely
    different paradigm which is much closer to how it is done in BHAC and Cactus etc.
    
    --> It will not be worth the work because we don't *want* the limiter to be active at the boundary and if it is,
        people should work on it. A posteriori limiting at the boundary is a waste of CPU time.
    
*/
