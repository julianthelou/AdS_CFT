#include <stdexcept>

#include "kernels/KernelUtils.h"
#include "kernels/GaussLegendreBasis.h" // interpolate
#include "kernels/aderdg/generic/c/standaloneRungeKutta.cpph"
using namespace kernels::aderdg::generic::c; // RungeKuttaIntegrator
using namespace kernels;

#include "Fortran/PDE.h"
namespace idx = CCZ4Fortran::StateVectorSequentialization;

#include <cmath>
#include "tarch/la/Vector.h"
using namespace tarch::la; // norm2

inline double norm2(const double* const x) {
	double r(0);
	for(int d=0; d<DIMENSIONS; d++) r+= x[d]*x[d];
	return std::sqrt(r);
}

#include "RadiativeBoundaryConditions.h"

using namespace CCZ4_RadBC;

constexpr int order = BaseSolverType::Order;
constexpr int numberOfVariables = BaseSolverType::NumberOfVariables;
constexpr int numberOfParameters = BaseSolverType::NumberOfParameters;
constexpr int numberOfData       = numberOfVariables+numberOfParameters;



void CCZ4_RadBC::RadiativeWavePDE::rightHandSide(const double* const x, const double* const Q, const double* const gradQ, double* S) const {
	double BgradQ[NumberOfVariables];
	algebraicSource(x,Q,S);
	nonConservativeProduct(x,Q,gradQ,BgradQ);
	for(int k=0; k<NumberOfVariables; k++) S[k] -= BgradQ[k];
}
		
void CCZ4_RadBC::RadiativeWavePDE::boundaryFluxContribution(const double* const x, const double* const Q, double** F) const {
	double r = norm2(x);
	
	for(int k=0; k<NumberOfVariables; k++)
	for(int i=0; i<DIMENSIONS; i++)
		F[i][k] = v0[k] * x[i]/r;
}

void CCZ4_RadBC::RadiativeWavePDE::eigenvalues(const double* const x, const double* const Q, double* Lambda) const {
	for(int k=0; k<NumberOfVariables; k++)
		Lambda[k] = v0[k];
}

void CCZ4_RadBC::RadiativeWavePDE::nonConservativeProduct(const double* const x, const double* const Q, const double* const gradQ, double* BgradQ) const {
	double r = norm2(x);
	const idx2 idx_gradQ(DIMENSIONS, NumberOfVariables);
	
	for(int k=0; k<NumberOfVariables; k++) {
		BgradQ[k] = 0;
		
		for(int i=0; i<DIMENSIONS; i++)
			BgradQ[k] += v0[k]*(x[i]/r) * gradQ[idx_gradQ(i,k)];
	}
}

void CCZ4_RadBC::RadiativeWavePDE::algebraicSource(const double* const x, const double* const Q, double* S) const {
	double r = norm2(x);
	for(int k=0; k<NumberOfVariables; k++)
		S[k] = - v0[k]*(Q[k]-Q0[k]) / r;
}

CCZ4_RadBC::RadiativeWavePDE::RadiativeWavePDE() {
	// This is interesting now: The hardcoded positions of the variables...
	// This is really somewhat shitty. Thank you, ExaHyPE.
	using namespace idx;

	newrad(phi, 0.0, 1.0); // log(phi) -> 0

	newrad(g11, 1.0, 1.0); // sic
	newrad(g12, 0.0, 1.0);
	newrad(g13, 0.0, 1.0);
	newrad(g22, 1.0, 1.0); // sic
	newrad(g13, 0.0, 1.0);
	newrad(g33, 1.0, 1.0); // sic

	newrad(G1, 0.0, 1.0);
	newrad(G2, 0.0, 1.0);
	newrad(G3, 0.0, 1.0);

	newrad(Theta, 0.0, 1.0);

	newrad(K , 0.0, 1.0);
	newrad(K0, 0.0, 1.0);

	newrad(A11, 0.0, 1.0);
	newrad(A12, 0.0, 1.0);
	newrad(A13, 0.0, 1.0);
	newrad(A22, 0.0, 1.0);
	newrad(A13, 0.0, 1.0);
	newrad(A33, 0.0, 1.0);

	newrad(lapse, 0.0, 1.0); // lapse->1, log(lapse) -> 0

	newrad(shift1, 0.0, 1.0);
	newrad(shift2, 0.0, 1.0);
	newrad(shift3, 0.0, 1.0);

	newrad(b1, 0.0, 1.0);
	newrad(b2, 0.0, 1.0);
	newrad(b3, 0.0, 1.0);

	/* Reasr all FO-CCZ4 helpers:
	* - logf->1 at the boundary goes to 0.
	* - df/r f->0 at the boundary goes also to 0 for all i.
	*/

	newrad(A1,   0.0, 1.0);
	newrad(A2,   0.0, 1.0);
	newrad(A3,   0.0, 1.0);
	newrad(B11,  0.0, 1.0);
	newrad(B21,  0.0, 1.0);
	newrad(B31,  0.0, 1.0);
	newrad(B12,  0.0, 1.0);
	newrad(B22,  0.0, 1.0);
	newrad(B32,  0.0, 1.0);
	newrad(B13,  0.0, 1.0);
	newrad(B23,  0.0, 1.0);
	newrad(B33,  0.0, 1.0);
	newrad(D111, 0.0, 1.0);
	newrad(D112, 0.0, 1.0);
	newrad(D113, 0.0, 1.0);
	newrad(D122, 0.0, 1.0);
	newrad(D123, 0.0, 1.0);
	newrad(D133, 0.0, 1.0);
	newrad(D211, 0.0, 1.0);
	newrad(D212, 0.0, 1.0);
	newrad(D213, 0.0, 1.0);
	newrad(D222, 0.0, 1.0);
	newrad(D223, 0.0, 1.0);
	newrad(D233, 0.0, 1.0);
	newrad(D311, 0.0, 1.0);
	newrad(D312, 0.0, 1.0);
	newrad(D313, 0.0, 1.0);
	newrad(D322, 0.0, 1.0);
	newrad(D323, 0.0, 1.0);
	newrad(D333, 0.0, 1.0);
	newrad(P1,   0.0, 1.0);
	newrad(P2,   0.0, 1.0);
	newrad(P3,   0.0, 1.0);

	// There are actually situations where the velocity != c.
	// i.e. for 1+log slicing:
	//   v0 = sqrt(2)
	//   {alp, phi} -> v0
	//   that means however that logLapse, logPhi -> log(sqrt(2)), right?
	
} // RadiativeWavePDE constructor

CCZ4_RadBC::RadiativeWavePDE& CCZ4_RadBC::RadiativeWavePDE::getSingleton() {
	static RadiativeWavePDE instance;
	return instance;
}


void CCZ4_RadBC::RadiativeBoundaryConditions::boundaryConditions(
	double* luh,
	double* FOut, double* QOut,
	const double* const FIn,
	const double* const QIn,
	const tarch::la::Vector<DIMENSIONS,double>& cellCentre,
	const tarch::la::Vector<DIMENSIONS,double>& cellSize,
	const double cellTime,
	const double cellDt,
	const int faceIndex, const int normalNonZero)
{
	constexpr int basisSize = order + 1;
	constexpr int basisX = basisSize, basisY = basisSize, basisZ = (DIMENSIONS==3?basisSize:1);
	constexpr int patchSize = basisX*basisY*basisZ*numberOfData;
	const tarch::la::Vector<DIMENSIONS,double> offsetOfPatch = cellCentre - 0.5 * cellSize;
	
	// This is for 3D.
	kernels::index
		idx_gradQi(basisZ, basisY, basisX),
		idx_luh(basisZ, basisY, basisX, numberOfData),
		idx_Q(basisSize, basisSize, numberOfData),
		idx_F(basisSize, basisSize, numberOfVariables);
	
	constexpr double cfl = 0.9; // I see no need to go further down

	RungeKuttaIntegrator<SolverType> integrator(pde, offsetOfPatch, cellSize, cfl);
	
	// This code is stolen from boundaryConditions.cpph:
	// Compute if face is "left" (0,2,4) or "right" face (1,2,3).
	const int f = faceIndex-2*normalNonZero;

	// Determine the free directions from the non-zero normal entry.
	int d1=0, d2=0;
	switch(normalNonZero) {
		case 0: d1=1; d2=2; break;
		case 1: d1=0; d2=2; break;
		case 2: d1=0; d2=1; break;
		default: std::abort(); // illegal value for normalNonZero
	}
  
	double QPatch[patchSize]; // This will always hold the nDim-dimensional current initial Patch value

	for(int i = 0; i < patchSize; i++)
		QPatch[i] = luh[i]; // Initial data: Copy first the complete cell
	
	// Do a gauss point integration in time
	double nodeTime = cellTime;
	for(int i=0; i < basisSize; i++) { // i == time
		const double weight = kernels::legendre::weights[order][i];
		const double nextNodeTime = cellDt * kernels::legendre::nodes[order][i];

		// QPatch is Initial Data for current integration step
		integrator.Integrate(nodeTime, nextNodeTime, QPatch);
		nodeTime = nextNodeTime;
		
		// Question: Do we need to weight the result with gaussLegendreWeights?

		// Loop over the boundary surface, here 3D -> 2D surface,
		// interpolate values at surface and compute the outside flux
		for(int j=0; j < basisSize; j++)
		for(int k=0; k < basisSize; k++) {
			double pos[DIMENSIONS];
			pos[normalNonZero] = cellCentre[normalNonZero] + (-0.5 + f)*cellSize[normalNonZero];
			pos[d2] = cellCentre[d2] + cellSize[d2] * (kernels::legendre::nodes[basisSize-1][j] - 0.5);
			pos[d1] = cellCentre[d1] + cellSize[d1] * (kernels::legendre::nodes[basisSize-1][k] - 0.5); 
			
			double *Q = QOut + idx_Q(i,j,0);
			double *F = FOut + idx_F(i,j,0);

			for(int n=0; n < numberOfVariables; n++) {
				Q[n] = kernels::legendre::interpolate(
					offsetOfPatch.data(),
					cellSize.data(),
					pos,
					numberOfData,
					n,
					order,
					QPatch
				);
			}
			
			// Luxation neccessary for the weird fluxes signature with double pointer.
			double DummyFluxes[3][numberOfVariables];
			double *Fluxes[3] = { DummyFluxes[0], DummyFluxes[1], DummyFluxes[2] };
			Fluxes[normalNonZero] = F;
			
			pde.boundaryFluxContribution(pos, Q, &Fluxes[0]);
		}
	}
}


void CCZ4_RadBC::DIM_CCZ4::mix(const double* const Q, const double* const CCZ4_Solution, const double* const BohrSommerfeld_Solution, double* Mixed_Solution) {
	double indicator = Q[idx::domain];
	
	// the DIM follows Dumbsers definitions, for instance https://arxiv.org/abs/1804.09491
	// Limits: indicator == 1 <-> inside physical domain  (solve CCZ4 only)
	//         indicator == 0 <-> outside physical domain (solve BohrSommerfeld only)
	
	if(indicator < 0) indicator = 0;
	else if(indicator > 1) indicator = 1;
	else throw std::domain_error("Indicator field is assumably NAN.");
	
	// simple linear crossover
	for(int i=0; i<numberOfVariables; i++) {
		Mixed_Solution[i] = indicator * CCZ4_Solution[i] + (indicator-1) * BohrSommerfeld_Solution[i];
	}
}

void CCZ4_RadBC::DIM_CCZ4::getPosition(const double* const Q, double* x) {
	// Well, ExaHyPE's design decisions...
	x[0] = Q[idx::posx];
	x[1] = Q[idx::posy];
	if(DIMENSIONS>2)
	x[2] = Q[idx::posz];
}

void CCZ4_RadBC::DIM_CCZ4::nonConservativeProduct(const double* const Q, const double* const gradQ, double* BgradQ) {
	double BgradQ_CCZ4[numberOfVariables], BgradQ_BohrSommerfeld[numberOfVariables], x[DIMENSIONS];
	
	getPosition(Q, x);
	CCZ4Fortran::PDE::nonConservativeProduct(Q, gradQ, BgradQ_CCZ4);
	RadiativeWavePDE::getSingleton().nonConservativeProduct(x, Q, gradQ, BgradQ_BohrSommerfeld);
	mix(Q, BgradQ_CCZ4, BgradQ_BohrSommerfeld, BgradQ);
}

void CCZ4_RadBC::DIM_CCZ4::algebraicSource(const double* const Q, double* S) {
	double S_CCZ4[numberOfVariables], S_BohrSommerfeld[numberOfVariables], x[DIMENSIONS];
	
	getPosition(Q, x);
	CCZ4Fortran::PDE::algebraicSource(Q, S_CCZ4);
	RadiativeWavePDE::getSingleton().algebraicSource(x, Q, S_BohrSommerfeld);
	mix(Q, S_CCZ4, S_BohrSommerfeld, S);
}

void CCZ4_RadBC::DIM_CCZ4::fusedSource(const double* const Q, const double* const gradQ, double* S) {
	double S_CCZ4[numberOfVariables], S_BohrSommerfeld[numberOfVariables], x[DIMENSIONS];
	
	getPosition(Q, x);
	CCZ4Fortran::PDE::fusedSource(Q, gradQ, S_CCZ4);
	RadiativeWavePDE::getSingleton().rightHandSide(x, Q, gradQ, S_BohrSommerfeld);
	mix(Q, S_CCZ4, S_BohrSommerfeld, S);
}

void CCZ4_RadBC::DIM_CCZ4::eigenvalues(const double* const Q, const int dIndex, double* lambda) {
	// Sorry, but mixing the eigenvalues is stupid. Everything is 1 anyway.
	CCZ4Fortran::PDE::eigenvalues(Q, dIndex, lambda);
}
